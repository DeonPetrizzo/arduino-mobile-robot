#include <Arduino.h>

//Runs all three modes: BT, linefollowing, maze solving
void run() {
  int numPresses = button.handleSuccessivePresses(2000);

  if (numPresses != -1 && numPresses != 0) {
    program = numPresses;
    drivetrain.set(0, 0, 0, 0);
    ledArray.changeAllStates(LOW);
    ledArray.walk(150, program, false);
  }

  switch (program) {
    case 1:
      runBTCmds();
      break;
    case 2:
    case 3:
      pos = senseArray.getPosition();
      intersection = senseArray.checkIntersection();

      if (pos != prevPos) ledArray.changeAllStates(LOW);
      else ledArray.indicatePosition(pos);

      if (program == 2) traverseMaze();
      else followLine(false);
      break;
    default:
      ledArray.pulse(200);
      serialReader.flush();
      break;
  }
  
  prevPos = pos;
}

//Makes a right or left turn as long as the error != 0 or drives straight depending on the inputted char
void handleIntersection(char dir) {
  if (dir == 'S') drivetrain.drive(LARGE_STEP, dir);
  else if (dir == 'B') dir = 'R';
  
  if (dir != 'S') {
    drivetrain.drive(4, dir);
    do {
      drivetrain.drive(-1, dir);
      error = senseArray.getError();
    } while (error != 0);
  }
}

//Prepaires for the second pass through the maze
void mazeSolved() {
  drivetrain.set(0, 0, 0, 0);
  if (passStatus == 1) {
    pathLength = 0;
    pathIndex = 0;
  }
  passStatus = !passStatus;
  while (!button.isPressed()) ledArray.blink(250);
  delay(1000);
}

//Drives the motors forward while on an intersection to validate sensor states
void pollSensors() {
  drivetrain.stop();
  while (true) {
    drivetrain.drive(-1, 'S');
    byte reading = senseArray.checkIntersection();
    if (intersection != reading && reading != NO_LINE && reading != FOLLOW_LINE) {
      intersection = reading;
      break;
    }
    else if (reading == NO_LINE || reading == FOLLOW_LINE) break;
  }
}

//Generates the shortest path through the maze by trimming out unecessary turns
void optimizePath(char dir) {
  int totalAngle = 0;
  path[pathLength] = dir;
  pathLength++;

  if (pathLength < 3 && path[pathLength-2] != 'B') return;

  //Reads the last 3 turns in path[] and adds their angle values to totalAngle
  for (byte i = 1; i <= 3; i++) {
    switch (path[pathLength - i]) {
      case 'R':
        totalAngle += 90;
        break;
      case 'B':
        totalAngle += 180;
        break;
      case 'L':
        totalAngle += 270;
        break;
    }
  }
  totalAngle %= 360; //Gets the angle as a number from 0 - 360 degrees

  //Replaces all 3 turns with 1 turn
  switch (totalAngle) {
    case 0:
      path[pathLength - 3] = 'S';
      break;
    case 90:
      path[pathLength - 3] = 'R';
      break;
    case 180:
      path[pathLength - 3] = 'B';
      break;
    case 270:
      path[pathLength - 3] = 'L';
      break;
  } 
  pathLength -= 2; //Removes the 2 unecessary turns from path[]
}

//Maze solving algorithm
void traverseMaze() {
  //Second pass: runs the optimum path generated by optimizePath()
  if (passStatus == 1) {
    if (intersection == FOLLOW_LINE) followLine(true);
    else {
      if (pathIndex >= pathLength) mazeSolved();
      else {
        if (path[pathIndex] == 'R' || path[pathIndex] == 'L') {
          drivetrain.stop();
          drivetrain.drive(LARGE_STEP, 'S');
        }
        handleIntersection(path[pathIndex]);
        pathIndex++;
      }
    }
    return;
  }

  //First pass: traverses the maze using the "left-hand" rule
  switch (intersection) {
    case FOLLOW_LINE:
      followLine(true);
      break;

    case LEFT_TURN:
      pollSensors();
      if (intersection == COMPLETE_INTERSECTION) break;
      drivetrain.stop();
      drivetrain.drive(LARGE_STEP, 'S');
      handleIntersection('L');
      optimizePath('L');
      break;

    case RIGHT_TURN:
      pollSensors();
      if (intersection == COMPLETE_INTERSECTION) break;
      drivetrain.stop();
      drivetrain.drive(LARGE_STEP, 'S');
      intersection = senseArray.checkIntersection();
      if (intersection == NO_LINE) {
        handleIntersection('R');
        optimizePath('R');
      } 
      else {
        handleIntersection('S');
        optimizePath('S');
      }
      break;

    case COMPLETE_INTERSECTION:
      drivetrain.stop();
      drivetrain.drive(LARGE_STEP, 'S');
      intersection = senseArray.checkIntersection();
      if (intersection == COMPLETE_INTERSECTION) mazeSolved();
      else {
        handleIntersection('L');
        optimizePath('L');
      }
      break;

    case NO_LINE:
      drivetrain.stop();
      drivetrain.drive(LARGE_STEP, 'S');
      handleIntersection('B');
      optimizePath('B');
      break;
  }
}

//PID line following with 90 degree turn handling
void followLine(bool isMazeSolving) {
  error = senseArray.getError();
  float pidVal = pidController.calculate(error);
  drivetrain.followLine(pidVal);

  if (!isMazeSolving) {
    drivetrain.stop();
    drivetrain.drive(LARGE_STEP, 'S');

    if (intersection == LEFT_TURN) handleIntersection('L');
    else if (intersection == RIGHT_TURN) handleIntersection('R');      
  }
}
 
//Runs serial commands: virtual joystick control, PID gain constant tuning, motor speed tuning
void runBTCmds() {
  serialReader.read(data);
  int cmd = serialReader.getCmd(data, prevData);

  switch (cmd) {
    case 0:
      while (data[0] != 0 && data[1] != 0) {
        serialReader.read(data);
        drivetrain.runJsControl(map(data[0], -60, 60, 0, 1023), map(data[1], -60, 60, 0, 1023));
        if (data[1] < 0) ledArray.blink(700);
        else ledArray.changeAllStates(LOW);
      }
      drivetrain.set(0, 0, 0, 0);
      serialReader.reset(data, prevData, 0, 2);
      break;

    case 1:
      pidController.setKp(data[2]);
      ledArray.changeState(0, HIGH);
      delay(1000);
      break;

    case 2:
      pidController.setKi(data[3]);
      ledArray.changeState(1, HIGH);
      delay(1000);
      break;

    case 3:
      pidController.setKd(data[4]);
      ledArray.changeState(2, HIGH);
      delay(1000);
      break;

    case 4:
      drivetrain.setSpeed(data[5]);
      ledArray.fill(250, map(data[5], 0, 255, 0, 4));
      delay(1000);
      break;
      
    default:
      break;
  }

  serialReader.update(data, prevData);
  ledArray.changeAllStates(LOW);
}
